// SPDX-License-Identifier: MIT
pragma solidity ^0.8.27;

import {RandomnessReceiverBase} from "randomness-solidity/src/RandomnessReceiverBase.sol";

/**
 * @title DiceRoller
 * @author dCipher Randomness Demo
 * @notice A smart contract that simulates dice rolling using verifiable randomness from dCipher
 * @dev Inherits from RandomnessReceiverBase to receive verifiable random numbers on-chain
 * 
 * This contract demonstrates how to integrate dCipher's randomness oracle to generate
 * provably fair random numbers for a simple dice rolling application. The dice roll
 * result is a number between 1 and 6, derived from the verifiable randomness.
 */
contract DiceRoller is RandomnessReceiverBase {
    /// @notice The most recent randomness value received from the oracle
    /// @dev Stored as bytes32, converted to uint256 for dice roll calculation
    bytes32 public latestRandomness;
    
    /// @notice The request ID of the most recent randomness request
    /// @dev Used to validate incoming randomness callbacks
    uint256 public latestRequestId;
    
    /// @notice Total number of dice rolls performed
    /// @dev Incremented with each rollDice call
    uint256 public rollCount;

    /**
     * @notice Emitted when a user initiates a dice roll
     * @param requestId The unique identifier for this randomness request
     * @param roller The address of the user who rolled the dice
     */
    event DiceRolled(uint256 indexed requestId, address indexed roller);
    
    /**
     * @notice Emitted when randomness is received from the oracle
     * @param requestId The unique identifier for this randomness request
     * @param randomValue The verifiable random value received
     */
    event RandomnessReceived(uint256 indexed requestId, bytes32 randomValue);

    /**
     * @notice Initializes the DiceRoller contract
     * @param _randomnessSender The address of the dCipher RandomnessSender contract
     * @param _owner The address that will own this contract
     * @dev The RandomnessSender address is network-specific (e.g., Base Sepolia)
     */
    constructor(address _randomnessSender, address _owner)
        RandomnessReceiverBase(_randomnessSender, _owner)
    {}

    /**
     * @notice Requests a random number and initiates a dice roll
     * @param callbackGasLimit The gas limit for the randomness callback (recommended: 100000)
     * @return requestId The unique identifier for this randomness request
     * @dev Requires payment in native token (ETH) to cover oracle fees
     * 
     * The function:
     * 1. Requests randomness from the dCipher oracle
     * 2. Stores the request ID for validation
     * 3. Increments the roll counter
     * 4. Emits a DiceRolled event
     * 
     * The actual dice result will be available after the oracle callback completes
     */
    function rollDice(uint32 callbackGasLimit) external payable returns (uint256) {
        (uint256 requestId, uint256 requestPrice) = _requestRandomnessPayInNative(callbackGasLimit);

        latestRequestId = requestId;
        rollCount++;

        emit DiceRolled(requestId, msg.sender);

        return requestId;
    }

    /**
     * @notice Callback function called by the oracle when randomness is ready
     * @param requestId The unique identifier for the randomness request
     * @param randomness The verifiable random value generated by dCipher
     * @dev Only callable by the RandomnessSender contract (enforced by parent)
     * 
     * This internal function:
     * 1. Validates the request ID matches the latest request
     * 2. Stores the randomness value
     * 3. Emits a RandomnessReceived event
     */
    function onRandomnessReceived(uint256 requestId, bytes32 randomness) internal override {
        require(latestRequestId == requestId, "Unexpected request ID");

        latestRandomness = randomness;

        emit RandomnessReceived(requestId, randomness);
    }

    /**
     * @notice Returns the result of the latest dice roll
     * @return A number between 1 and 6 representing the dice roll result
     * @dev Converts the randomness bytes32 to uint256, applies modulo 6, and adds 1
     * 
     * Returns 0 if no randomness has been received yet. Always check that
     * latestRandomness is not zero before trusting the result.
     */
    function getLatestDiceRoll() external view returns (uint256) {
        return (uint256(latestRandomness) % 6) + 1;
    }
}
